! *********************************************************************

      PROGRAM DecomposeGrid

! *********************************************************************
! ***  DecomposeGrid
! ***  Decomposes grid for parallel execution of RiCOM, based on
! ***             partition table generated by Metis 4.
! ***  Reads preprocessed binary grid file for RiCOM (prepared by PreMod5)
! ***             Then divides grid in ncpu parts in separate directories.
! ***  Reference: Jacek
! ***  Written by: Roy A. Walters
! ***  
! ***  IMPORTANT NOTE:
! ***  This program is provided for personal use and may not be distributed
!      to anyone else without the author's explicit permission.
! *********************************************************************

! *********************************************************************
! *** Exit Codes
! *** 70 unable to open input file
! *** 71 problem allocating arrays
! *** 72 Unknown parameter value/invalid input
! *********************************************************************

      USE MainData
      
      implicit none

! *** local variables
      integer ivar(20)
      real rvar(5)
      real ctime0, stime0, ctime1, stime1, etime

      include 'RCMversion.h'

! *** initialization
      call ticktock(ctime0,stime0)
      CALL DataInput(ivar,rvar)
      call PartitionGrid()
      call decompose()
      call decompose_restart()
      call OutputGrids
      call ticktock(ctime1,stime1)
      etime = ctime1 - ctime0
      write(6,*) ' Elapsed proc time in input=', etime
      etime = stime1 - stime0
      write(6,*) ' Elapsed sys time in input=', etime


      STOP
      END

!*****************************************************************
!*****************************************************************

      SUBROUTINE DataInput(ivar, rvar)

! *** Read grid data created by PROGRAM PREMOD, read boundary data,
! *** and initialize model.

      USE MainData

      implicit none

! *** passed variables
      integer ivar(*)
      real rvar(*)

! *** local variables
      integer :: i,j,k,istat,ierr,nn,ncn2,n1,n2,js
      integer nnp,nndf,npvx,ndfv,iopt,ndim
      logical ResOK, openbinfile
      CHARACTER FNAME*256, ans*1

! *** START
      write(*,*) ' A grid decomposition program for the model'
      write(*,*) ' RiCOM Version ',trim(version),' (River and Coastal Ocean Model)'
      write(*,*) ' created by Roy Walters,'
      write(*,*) ' Internet:  rawalters@gmail.com'
      write(*,*) ' Program size: Allocatable arays. A message will appear'
      write(*,*) '               if there is insufficient memory'
      write(*,*) ' '


! *** Initial values
      TET = 0.

      ResOK = OpenBinFile(22,'Open pre-processed Grid File',fname, &
     &    "Input file(*.rcm),*.rcm;All files(*.*),*.*;")

      if(.not.resOK) then
        write(*,*), 'Unable to open input file'
        call exit(71)
      endif

!      OPEN(UNIT=22,file=GridFileName,status='OLD',FORM='UNFORMATTED')      
      READ (22) NE,NTYPE,NP,NPR,NCN,nsides,nnbr,izup,ifront

!  Main arrays for grid
      ALLOCATE (nen(ne,ncn),xyz(np,3),area(ne),nbc(np),alfa(np), &
        ieadj(5,ne),numsideT(4,ne),IECode(ne), STAT = istat )

      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate main storage arrays'
        call exit(71)
      endif

      READ (22) ((NEN(J,K),K=1,NCN),J=1,NE),(IECode(j),J=1,NE), &
     &         ((XYZ(J,K),J=1,NP),K=1,3),(ALFA(j),J=1,NP),         &
     &         (NBC(J),J=1,NP)
      
      if(nsides.gt.0) then
!  Side-based arrays
        ALLOCATE (sdep(0:nsides),slen(nsides),refdep(nsides),sdx(nsides),sdy(nsides), &
          sxy(2,nsides),dlinv(nsides),iside(3,nsides),iends(2,nsides), STAT = istat )
        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate side-based storage arrays'
          call exit(71)
        endif

        READ(22) (area(j),j=1,ne),((ieadj(k,j),k=1,5),j=1,ne),((numsideT(k,j),j=1,ne),k=1,4) 
        READ(22) ((iside(k,j),k=1,2),j=1,nsides),((sxy(k,j),k=1,2),j=1,nsides)
        READ(22) (refdep(j),j=1,nsides),(slen(j),j=1,nsides)
        READ(22) (sdx(j),j=1,nsides),(sdy(j),j=1,nsides),(dlinv(j),j=1,nsides)
        READ(22,IOSTAT=istat) ((iends(k,j),k=1,2),j=1,nsides)
! *** temporarily fill iends until put in PreMod
        if(istat.ne.0) then
          do nn=1,ne
            ncn2 = ncn -1 + min0(1,nen(nn,ncn))
            do j=1,ncn2
              N1=NEN(nn,j)
              N2=NEN(nn,mod(j,ncn2)+1)
              js = numsideT(j,nn)
              iends(1,js ) = n1
              iends(2,js) = n2
            enddo
          enddo
        endif
      else
        nsides = 0
      endif
      CLOSE(unit=22)
 
      write(6,*) ' ne,ncn,ntype=',ne,ncn,ntype
      write(6,*) ' np,nsides,nnbr=',np,nsides,nnbr

! *** restart file
!      write(*,*) ' Decompose restart file? (Y/N)'
!      READ(*,'(a)') ans
      ans(1:1) = 'N'
      
      if(ans(1:1).eq.'Y'.or.ans(1:1).eq.'y') then

        ResOK = OpenBinFile(2,'Open restart File',fname, &
          "Input file(*.bin),*.bin;All files(*.*),*.*;")

        if(.not.resOK) then
          write(*,*), 'Unable to open restart file'
          call exit(71)
        endif
        
        irst = 1

! *** If iwind = 3 (i.e. NZLAM wind/pressure input) read in Analysis time for restart file
        IF ((iwind .eq. 2) .or. (iwind .eq. 3)) THEN
          READ(2) TET,nnp,nndf,npvx,ndfv,iopt,iAnalysisTime
		  write(*,*), 'Analysis time from restart file', iAnalysisTime
        ELSE
          READ(2) TET,nnp,nndf,npvx,ndfv,iopt
        END IF
 
        ndim = max(nsides,ne)
        npv = npvx
        allocate ( eta(0:ndim),un(npv,nsides),ut(npv,nsides),ut1(npv,nsides),&
                   ut2(npv,nsides), STAT = istat )
        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate dependent variables'
          call exit(71)
        endif
        
        READ(2) (eta(I),I=1,nnp),(un(1,i),i=1,nnp),(ut(1,i),i=1,nnp)
!        eta = amax1(eta-0.1,elev)
        if(npvx.gt.1) then
          do k=2,npvx
            read(2,end=188) (un(k,j),j=1,nnp),(ut(k,j),j=1,nnp)
          enddo
        endif
        ut1 = ut
        ut2 = ut
        read(2,end=188) ((ut1(k,j),k=1,npvx),j=1,nnp)
        read(2,end=188) ((ut2(k,j),k=1,npvx),j=1,nnp)
188     CLOSE (unit=2)
      else
        irst = 0
      endif

      RETURN

      END

!*****************************************************************
!*****************************************************************

      Subroutine PartitionGrid()

      USE MainData
      
      implicit none

! *** local variables
      integer j, k, istat
      integer etype, numflag, edgecut
      integer, allocatable ::  eptr(:), eind(:), vwgt(:), vsize(:) 
      real, allocatable :: tpwgts(:)
      logical ResOK, openfile
      CHARACTER FNAME*256, ans*1

      write(*,*) ' Partition grid (Y/N)?'
      READ(*,'(a)') ans
      
      if(ans(1:1).eq.'Y'.or.ans(1:1).eq.'y') then
      
        write(*,*) ' Enter the number of partitions'
        read(*,*) nproc

!  call metis routines - v4
      
        numflag = 1
        if(ncn.eq.4) then
          etype = 4
        elseif(ncn.eq.3) then
          etype = 1
        else
          write(*,*) ' Invalid value for ncn ',ncn
          stop
        endif

        ALLOCATE (eind(4*ne),epart(ne),npart(np), STAT = istat )
        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate metis arrays'
          call exit(71)
        endif

        do j=1,ne
          do k=1,3
            eind(3*(j-1)+k) = nen(j,k)
          enddo
        enddo

        if(nproc.gt.1) then
          call metis_partmeshdual(ne,np,eind,etype,numflag,nproc,&
                              edgecut,epart,npart)
        else
          epart = 1
          npart = 1
        endif

                              
!  call metis routines - v5
      
!      ncommon = 2

!      ALLOCATE (eptr(ne+1),eind(4*ne),epart(ne),npart(np),&
!                vwgt(ne), vsize(ne),tpwgts(ne), STAT = istat )
!      if(istat.ne.0) then
!        write(*,*) 'FATAL ERROR: Cannot allocate metis arrays'
!        call exit(71)
!      endif

!      call metis_partmeshdual(ne,np,eptr,eind,vwgt,vsize,ncommon,nparts,&
!                              tpwgts,options,objval,epart,npart)

!  write output file of partitions(element number)
        open(21,file='partitiontable.dat', status='unknown')
        do j=1,ne
          write(21,*) epart(j)
        enddo
        close(21)

      else 
        ResOK = OpenFile(22,'Open Partition Table File',fname, &
     &    "Input file(*.lel),*.lel;All files(*.*),*.*;")

        if(.not.resOK) then
          write(*,*), 'Unable to open partition file'
          call exit(71)
        endif

        ALLOCATE (epart(ne), STAT = istat )
        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate partition array'
          call exit(71)
        endif
        
        do j=1,ne
          read(22,*) epart(j)
        enddo
        close(22)
      
      endif


      RETURN
      END

!*****************************************************************
!*****************************************************************

      Subroutine decompose()

      USE MainData
      
      implicit none

! *** local variables
      integer j,j2,jp,jp2,k,kk,istat,ncn2,nn,ep,nepmax,neh,nehmax
      integer nspmax,mr,mr2,ns,nppmax,eG
      integer, allocatable :: ncnt(:)
      logical found

! *** determine size of partition arrays and form local to global map

      ALLOCATE (nep(nproc),nehalo(nproc),ncnt(nproc),npp(nproc),nphalo(nproc),&
                nsp(nproc),nshalo(nproc),commid(nproc,nproc),&
                elemapG2L(2,ne),nodemapG2L(2,np), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate decompose arrays'
        call exit(71)
      endif
      
      !debug
      open(99,file='basedata.dat',status='unknown')
      write(99,*) ' global element data=ne,npart,nen(1:4),numside(1:4)'
      do j=1,ne
        write(99,'(10i5)') j,epart(j),(nen(j,k),k=1,ncn),(numsideT(k,j),k=1,ncn)
      enddo
      
      nep = 0
      nehalo = 0
      elemapG2L = 0
      
! *** first find problem size and set G2L mapping

      do j=1,ne
        nn = nep(epart(j)) + 1
        elemapG2L(1,j) = epart(j)
        elemapG2L(2,j) = nn
        nep(epart(j)) = nn
        !  count halo elements
        ncn2 = ncn -1 + min0(1,nen(j,ncn))
        do k=1,ncn2
          j2 = ieadj(k+1,j)
          if(j2.gt.0) then
!            write(*,*) ' j,k,mr,j2,p1,p2',j,k,mr,j2,epart(j),epart(j2)
            if(epart(j).ne.epart(j2)) then
              nehalo(epart(j)) = nehalo(epart(j)) + 1
            endif
          endif
        enddo
      enddo
      
      write(*,*) ' nep=',(nep(j),j=1,nproc)
      write(*,*) ' nehalo=',(nehalo(j),j=1,nproc)

! *** form local to global map for elements

      nepmax = maxval(nep) + maxval(nehalo)
      nehmax = nproc*maxval(nehalo)
      ALLOCATE (elemapL2G(nepmax,nproc), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate L2G map array'
        call exit(71)
      endif
      
      elemapL2G = 0
      ncnt = 0
      commid = 0
      
      do j=1,ne
        ep = elemapG2L(1,j)
        nn = elemapG2L(2,j)
        elemapL2G(nn,ep) = j  !interior element
        ncn2 = ncn -1 + min0(1,nen(j,ncn))
        ! add halo elements
        kk = 0
        do k=1,ncn2
          j2 = ieadj(k+1,j)
          if(j2.gt.0) then
!            write(*,*) ' j,k,mr,j2,p1,p2',j,k,j2,epart(j),epart(j2)
            if(epart(j).ne.epart(j2)) then !halo pairs
              commid(epart(j),epart(j2))=1
              ncnt(ep) = ncnt(ep) + 1
              neh = nep(ep)+ncnt(ep)
              elemapL2G(neh,ep) = j2   !exterior halo element
            endif
          endif
        enddo
      enddo

      write(99,*) ' halo element data before dup'
      do jp=1,nproc
        write(99,*) ' jp, nep, nehalo=',jp, nep(jp),nehalo(jp)
        write(99,'(10i5)') (elemapL2G(j,jp),j=nep(jp)+1,nep(jp)+nehalo(jp))
      enddo
      
! *** eliminate duplicate external halo elements
      do jp=1,nproc
        if(nehalo(jp).le.1) cycle
        neh = 1
        do k=2,nehalo(jp)
          nn = nep(jp) + k
          j = elemapL2G(nn,jp)
          found = .false.
          do kk=1,neh
            nn = nep(jp) + kk
            j2 = elemapL2G(nn,jp)
            if(j.eq.j2) then
              found = .true.
              exit
            endif
          enddo
          if(.not.found) then
            neh = neh + 1
            nn = nep(jp) + neh
            elemapL2G(nn,jp) = j
          endif
        enddo
        nehalo(jp) = neh
      enddo

!      write(99,*) ' halo element data after dup'
!      do jp=1,nproc
!        write(99,*) ' jp, nep, nehalo=',jp, nep(jp),nehalo(jp)
!        write(99,'(10i5)') (elemapL2G(j,jp),j=nep(jp)+1,nep(jp)+nehalo(jp))
!      enddo

      write(*,*) ' nep=',(nep(j),j=1,nproc)
      write(*,*) ' nehalo=',(nehalo(j),j=1,nproc)

      !debug
      write(99,*) ' global 2 local element data=ne,npart,nn'
      do j=1,ne
        write(99,'(10i5)') j,elemapG2L(1,j),elemapG2L(2,j)
      enddo      
      
      write(99,*) ' local element data= npart,j,mapL2G'
      do jp=1,nproc
        write(99,*) ' jp, nep, nehalo=',nep(jp),nehalo(jp)
        do j=1,nep(jp)+nehalo(jp)
          write(99,'(10i5)') jp,j,elemapL2G(j,jp)
        enddo
      enddo
      

      
! *** form local to global map for sides

      nspmax = 4*(maxval(nep) + maxval(nehalo))
      ALLOCATE (sidemapL2G(nspmax,nproc),sidemapG2L(nproc,nsides), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate L2G map array'
        call exit(71)
      endif
      
      nsp = 0
      nshalo = 0
      sidemapL2G = 0
      sidemapG2L = 0
      
      do j=1,ne
        ep = epart(j)
        ns = nsp(ep)
        ncn2 = ncn -1 + min0(1,nen(j,ncn))
        do k=1,ncn2
          mr = numsideT(k,j)
          ns = ns + 1
          sidemapL2G(ns,ep) = mr
!          sidemapG2L(ep,mr) = ns
!          write(*,*) ' ns,ep,sidemapL2G=',ns,ep,sidemapL2G(ns,ep) 
        enddo
        nsp(ep) = ns
      enddo
      
      write(*,*) ' nsp=',(nsp(j),j=1,nproc)

      !debug
      write(99,*) ' local side data= npart,j,sidemapL2G'
           
      ! eliminate duplicates
      do jp=1,nproc
        ns = 1
        mr = sidemapL2G(ns,jp)
        sidemapG2L(jp,mr) = ns
        do k=2,nsp(jp)
          mr = sidemapL2G(k,jp)
          found = .false.
          do kk=1,k-1
            mr2 = sidemapL2G(kk,jp)
            if(mr2.eq.mr) then
              found = .true.
              exit
            endif
          enddo
          if(.not.found) then
            ns = ns + 1
            sidemapL2G(ns,jp) = mr
            sidemapG2L(jp,mr) = ns
 !           write(*,*) ' jp,k,kk,mr,mr2,ns=',jp,k,kk,mr,mr2,ns
 !          write(*,*) ' ns,ep,L2G,G2L=',ns,jp,sidemapL2G(ns,jp),sidemapG2L(jp,mr) 
         endif
        enddo
        nsp(jp) = ns
        ! add sides for halo
        do j=nep(jp)+1,nep(jp)+nehalo(jp)
          eG = elemapL2G(j,jp)
          jp2 = epart(eG)
          ncn2 = ncn -1 + min0(1,nen(eG,ncn))
          do k=1,ncn2
            mr = numsideT(k,eG)
            ns = ns + 1
            sidemapL2G(ns,jp) = mr
!            write(*,*) ' add ns,ep,sidemapL2G=',ns,jp,sidemapL2G(ns,jp) 
!           write(*,*) '  add ns,ep,L2G,G2L=',ns,jp,sidemapL2G(ns,jp),sidemapG2L(jp,mr) 
          enddo
        enddo
        nshalo(jp) = ns - nsp(jp)
        ! eliminate duplicates
        ns = nsp(jp)
        do k=nsp(jp)+1,nsp(jp)+nshalo(jp)
          mr = sidemapL2G(k,jp)
          found = .false.
          do kk=1,k-1
            mr2 = sidemapL2G(kk,jp)
            if(mr2.eq.mr) then
              found = .true.
              exit
            endif
          enddo
          if(.not.found) then
            ns = ns + 1
            sidemapL2G(ns,jp) = mr
!            sidemapG2L(jp,mr) = ns
!            sidemapEP(ns,jp) = sidemapEP(k,jp)
 !           write(*,*) ' jp,k,kk,mr,mr2,ns=',jp,k,kk,mr,mr2,ns
!           write(*,*) '  dup ns,ep,L2G,G2L=',ns,jp,sidemapL2G(ns,jp),sidemapG2L(jp,mr) 
          endif
        enddo
        nshalo(jp) = ns - nsp(jp)
        write(99,*) ' jp, nsp, nshalo=',nsp(jp),nshalo(jp)
        do j=1,nsp(jp)+nshalo(jp)
          write(99,'(10i5)') jp,j,sidemapL2G(j,jp)
        enddo
      enddo
     
      write(*,*) ' nsp=',(nsp(j),j=1,nproc)
      write(*,*) ' nshalo=',(nshalo(j),j=1,nproc)
     
! *** form local to global map for nodes

      nppmax = 4*(maxval(nep) + maxval(nehalo))
      ALLOCATE (nodemapL2G(nppmax,nproc), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate L2G map array'
        call exit(71)
      endif
      
      npp = 0
      nphalo = 0
      nodemapL2G = 0
      
      do j=1,ne
        ep = elemapG2L(1,j)
        nn = elemapG2L(2,j)
        ns = npp(ep)
        ncn2 = ncn -1 + min0(1,nen(j,ncn))
        do k=1,ncn2
          mr = nen(j,k)
          nodemapL2G(ns+1,ep) = mr
          ns = ns + 1
        enddo
        npp(ep) = ns
      enddo
      
      write(*,*) ' npp=',(npp(j),j=1,nproc)

      !debug
      write(99,*) ' local node data= npart,j,nodemapL2G'
      
      ! eliminate duplicates
      do jp=1,nproc
        ns = 1
        do k=2,npp(jp)
          mr = nodemapL2G(k,jp)
          found = .false.
          do kk=1,k-1
            mr2 = nodemapL2G(kk,jp)
            if(mr2.eq.mr) then
              found = .true.
              exit
            endif
          enddo
          if(.not.found) then
            ns = ns + 1
            nodemapL2G(ns,jp) = mr
          endif
        enddo
        npp(jp) = ns
        ! add nodes for halo
        do j=nep(jp)+1,nep(jp)+nehalo(jp)
          eG = elemapL2G(j,jp)
          ncn2 = ncn -1 + min0(1,nen(eG,ncn))
          do k=1,ncn2
            mr = nen(eG,k)
            nodemapL2G(ns+1,jp) = mr
            ns = ns + 1
          enddo
        enddo
        nphalo(jp) = ns - npp(jp)
        ! eliminate duplicates
        ns = npp(jp)
        do k=npp(jp)+1,npp(jp)+nphalo(jp)
          mr = nodemapL2G(k,jp)
          found = .false.
          do kk=1,k-1
            mr2 = nodemapL2G(kk,jp)
            if(mr2.eq.mr) then
              found = .true.
              exit
            endif
          enddo
          if(.not.found) then
            ns = ns + 1
            nodemapL2G(ns,jp) = mr
          endif
        enddo
        nphalo(jp) = ns - npp(jp)
        write(99,*) ' jp, npp, nphalo=',npp(jp),nphalo(jp)
        do j=1,npp(jp)+nphalo(jp)
          write(99,'(10i5)') jp,j,nodemapL2G(j,jp)
        enddo
      enddo
      
      write(*,*) ' npp=',(npp(j),j=1,nproc)
      write(*,*) ' nphalo=',(nphalo(j),j=1,nproc)
      
! *** construct communication structure
      call GenerateEleCommMap()

      RETURN
      END

!*****************************************************************
!*****************************************************************

      Subroutine GenerateEleCommMap()

      USE MainData
      
      implicit none

! *** local variables
      integer :: j,j2,jp,jp2,istat,ncomm_max,maxpoly,maxedge
      integer :: eG,eG2,n1,n2,k,kk,ncn2,nG,nG2
      logical :: found
      
      ALLOCATE (ncomm(nproc), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate ncomm array'
        call exit(71)
      endif

      ncomm = sum(commid,2)
      ncomm_max = maxval(ncomm(1:nproc))
      write(*,*) ' ncomm= ',(ncomm(jp),jp=1,nproc)
      
! *** now the dirty work
      ALLOCATE (icomm(ncomm_max,nproc),ecomm(ncomm_max,nproc), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate icomm,ecomm arrays'
        call exit(71)
      endif
      
      maxpoly = maxval(nehalo)
      maxedge = maxval(nshalo)
      ALLOCATE (ine(ncomm_max,nproc),ene(ncomm_max,nproc),&
                ins(ncomm_max,nproc),ens(ncomm_max,nproc),&
                inh(ncomm_max,nproc),enh(ncomm_max,nproc),&
                ipoly(maxpoly,ncomm_max,nproc),epoly(maxpoly,ncomm_max,nproc), &
                iedge(maxedge,ncomm_max,nproc),eedge(maxedge,ncomm_max,nproc), &
                ihalo(maxedge,ncomm_max,nproc),ehalo(maxedge,ncomm_max,nproc), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate ine,ene arrays'
        call exit(71)
      endif

      ncomm = 0
      ine = 0
      ene = 0
      ipoly = 0
      epoly = 0
      ins = 0
      ens = 0
      iedge = 0
      eedge = 0
      inh = 0
      enh = 0
      ihalo = 0
      ehalo = 0
      do jp=1,nproc
        do jp2 = jp+1,nproc
          if(commid(jp,jp2).eq.0) cycle
          ncomm(jp) = ncomm(jp) + 1
          ncomm(jp2) = ncomm(jp2) + 1
          n1 = ncomm(jp)
          n2 = ncomm(jp2)
          icomm(n1,jp) = jp
          icomm(n2,jp2) = jp
          ecomm(n1,jp) = jp2
          ecomm(n2,jp2) = jp2

! *** first element swaps

          do j = nep(jp)+1,nep(jp)+nehalo(jp) !parse element halo of jp
            eG = elemapL2G(j,jp)
            if(epart(eG).eq.jp2) then  !found one, add to epoly
              ene(n1,jp) = ene(n1,jp) + 1
              epoly(ene(n1,jp),n1,jp) = j
              ine(n2,jp2) = ine(n2,jp2) + 1
              j2 = elemapG2L(2,eG)
              ipoly(ine(n2,jp2),n2,jp2) = j2
            endif
          enddo

          do j = nep(jp2)+1,nep(jp2)+nehalo(jp2) !parse element halo of jp2
            eG = elemapL2G(j,jp2)
            if(epart(eG).eq.jp) then  !found one, add to epoly
              ene(n2,jp2) = ene(n2,jp2) + 1
              epoly(ene(n2,jp2),n2,jp2) = j
              ine(n1,jp) = ine(n1,jp) + 1
              j2 = elemapG2L(2,eG)
              ipoly(ine(n1,jp),n1,jp) = j2
            endif
          enddo

!        write(*,*) ' before dups jproc,ncomm= ',jp,ncomm(jp)
!        do k=1,ncomm(jp)
!          write(*,*) '    icomm,ecomm,ine,ene= ',icomm(k,jp),ecomm(k,jp),ine(k,jp),ene(k,jp)
!          write(*,*) '    ipoly= ',(ipoly(kk,k,jp),kk=1,ine(k,jp))
!          write(*,*) '    epoly= ',(epoly(kk,k,jp),kk=1,ene(k,jp))
!        enddo
!        write(*,*) ' '

! *** remove duplicates in ipoly (epoly is ok)

          if(ine(n1,jp).gt.1) then
            kk = 1
            do j = 2,ine(n1,jp)
              found = .false.
              do k = 1,kk
                if(ipoly(j,n1,jp).eq.ipoly(k,n1,jp)) then
                  found = .true.
                  exit
                endif
              enddo
              if(.not.found) then
                kk = kk + 1
                ipoly(kk,n1,jp) = ipoly(j,n1,jp)
              endif
            enddo
            ine(n1,jp) = kk
          endif

          if(ine(n2,jp).gt.1) then
            kk = 1
            do j = 2,ine(n2,jp)
              found = .false.
              do k = 1,kk
                if(ipoly(j,n2,jp).eq.ipoly(k,n2,jp)) then
                  found = .true.
                  exit
                endif
              enddo
              if(.not.found) then
                kk = kk + 1
                ipoly(kk,n2,jp) = ipoly(j,n2,jp)
              endif
            enddo
            ine(n2,jp) = kk
          endif

!        write(*,*) ' after dups jproc,ncomm= ',jp,ncomm(jp)
!        do k=1,ncomm(jp)
!          write(*,*) '    icomm,ecomm,ine,ene= ',icomm(k,jp),ecomm(k,jp),ine(k,jp),ene(k,jp)
!          write(*,*) '    ipoly= ',(ipoly(kk,k,jp),kk=1,ine(k,jp))
!          write(*,*) '    epoly= ',(epoly(kk,k,jp),kk=1,ene(k,jp))
!        enddo
!        write(*,*) ' '

! *** then side(edge) swaps

          do j = 1,nsp(jp)  !parse sides to find interfaces
            nG = sidemapL2G(j,jp)
            j2 = sidemapG2L(jp2,nG)
            if(j2.gt.0) then  !found one, add to iedge,eedge
              ins(n1,jp) = ins(n1,jp) + 1
              iedge(ins(n1,jp),n1,jp) = j
              ens(n1,jp) = ens(n1,jp) + 1
              eedge(ens(n1,jp),n1,jp) = j
              ins(n2,jp2) = ins(n2,jp2) + 1
              iedge(ins(n2,jp2),n2,jp2) = j2
              ens(n2,jp2) = ens(n2,jp2) + 1
              eedge(ens(n2,jp2),n2,jp2) = j2
            endif
          enddo


!          write(*,*) ' iedge  jproc,ncomm= ',jp,ncomm(jp)
!          do k=1,ncomm(jp)
!            write(*,*) '    icomm,ecomm,ins,ens= ',icomm(k,jp),ecomm(k,jp),ins(k,jp),ens(k,jp)
!            write(*,*) '    iedge= ',(iedge(kk,k,jp),kk=1,ins(k,jp))
!            write(*,*) '    eedge= ',(eedge(kk,k,jp),kk=1,ens(k,jp))
!          enddo
!          write(*,*) ' '

! *** then halo side(edge) swaps

          do j = nsp(jp)+1,nsp(jp)+nshalo(jp) !parse side halo of jp
            nG = sidemapL2G(j,jp)
            if(sidemapG2L(jp2,nG).gt.0) then  !found one, add to epoly
              enh(n1,jp) = enh(n1,jp) + 1
              ehalo(enh(n1,jp),n1,jp) = j
              inh(n2,jp2) = inh(n2,jp2) + 1
              j2 = sidemapG2L(jp2,nG)
              ihalo(inh(n2,jp2),n2,jp2) = j2
            endif
          enddo

          do j = nsp(jp2)+1,nsp(jp2)+nshalo(jp2) !parse side halo of jp2
            nG = sidemapL2G(j,jp2)
            if(sidemapG2L(jp,nG).gt.0) then  !found one, add to epoly
              enh(n2,jp2) = enh(n2,jp2) + 1
              ehalo(enh(n2,jp2),n2,jp2) = j
              inh(n1,jp) = inh(n1,jp) + 1
              j2 = sidemapG2L(jp,nG)
              ihalo(inh(n1,jp),n1,jp) = j2
            endif
          enddo

          write(*,*) ' before dups jproc,ncomm= ',jp,ncomm(jp)
          do k=1,ncomm(jp)
            write(*,*) '    icomm,ecomm,inh,enh= ',icomm(k,jp),ecomm(k,jp),inh(k,jp),enh(k,jp)
            write(*,*) '    ihalo= ',(ihalo(kk,k,jp),kk=1,inh(k,jp))
            write(*,*) '    ehalo= ',(ehalo(kk,k,jp),kk=1,enh(k,jp))
          enddo
          write(*,*) ' '

! *** remove duplicates in ihalo (ehalo is ok)

          if(inh(n1,jp).gt.1) then
            kk = 1
            do j = 2,inh(n1,jp)
              found = .false.
              do k = 1,kk
                if(ihalo(j,n1,jp).eq.ihalo(k,n1,jp)) then
                  found = .true.
                  exit
                endif
              enddo
              if(.not.found) then
                kk = kk + 1
                ihalo(kk,n1,jp) = ihalo(j,n1,jp)
              endif
            enddo
            inh(n1,jp) = kk
          endif

          if(inh(n2,jp).gt.1) then
            kk = 1
            do j = 2,inh(n2,jp)
              found = .false.
              do k = 1,kk
                if(ihalo(j,n2,jp).eq.ihalo(k,n2,jp)) then
                  found = .true.
                  exit
                endif
              enddo
              if(.not.found) then
                kk = kk + 1
                ihalo(kk,n2,jp) = ihalo(j,n2,jp)
              endif
            enddo
            inh(n2,jp) = kk
          endif

          write(*,*) ' after dups jproc,ncomm= ',jp,ncomm(jp)
          do k=1,ncomm(jp)
            write(*,*) '    icomm,ecomm,ins,ens= ',icomm(k,jp),ecomm(k,jp),inh(k,jp),enh(k,jp)
            write(*,*) '    ihalo= ',(ihalo(kk,k,jp),kk=1,inh(k,jp))
            write(*,*) '    ehalo= ',(ehalo(kk,k,jp),kk=1,enh(k,jp))
          enddo
          write(*,*) ' '

        enddo
      enddo
      

! *** write it out to debug
      do jp=1,nproc
        write(*,*) ' jproc,ncomm= ',jp,ncomm(jp)
        do k=1,ncomm(jp)
          write(*,*) '    icomm,ecomm,ine,ene= ',icomm(k,jp),ecomm(k,jp),ine(k,jp),ene(k,jp)
          write(*,*) '    ipoly= ',(ipoly(kk,k,jp),kk=1,ine(k,jp))
          write(*,*) '    epoly= ',(epoly(kk,k,jp),kk=1,ene(k,jp))
          write(*,*) '    icomm,ecomm,ins,ens= ',icomm(k,jp),ecomm(k,jp),ins(k,jp),ens(k,jp)
          write(*,*) '    iedge= ',(iedge(kk,k,jp),kk=1,ins(k,jp))
          write(*,*) '    eedge= ',(eedge(kk,k,jp),kk=1,ens(k,jp))
          write(*,*) '    icomm,ecomm,inh,enh= ',icomm(k,jp),ecomm(k,jp),inh(k,jp),enh(k,jp)
          write(*,*) '    ihalo= ',(ihalo(kk,k,jp),kk=1,inh(k,jp))
          write(*,*) '    ehalo= ',(ehalo(kk,k,jp),kk=1,enh(k,jp))
        enddo
        write(*,*) ' '
      enddo

      RETURN
      END

!*****************************************************************
!*****************************************************************

      Subroutine decompose_restart()

      USE MainData
      
      implicit none

! *** local variables

      RETURN
      END

!*****************************************************************
!*****************************************************************

      Subroutine OutputGrids

      USE MainData
      
      implicit none

! *** local variables
      integer j,jp,k,kk,istat,myproc,maxbufsize
      integer nG,eG,sG,ncn2
      integer nepmax,nppmax,nspmax,netot,nptot,nstot
      integer, allocatable :: elemapG2Lp(:),nodemapG2Lp(:), sidemapG2Lp(:)
      integer, allocatable :: nenp(:,:),ieadjp(:,:),numsideTp(:,:),IECodep(:),nbcp(:)
      integer, allocatable :: isidep(:,:),iendsp(:,:)
      real, allocatable :: xyzp(:,:),alfap(:)
      real, allocatable ::  Areap(:),sdepp(:),slenp(:),refdepp(:),sdxp(:),sdyp(:)
      real, allocatable ::  sxyp(:,:), dlinvp(:)
      character*6 :: PEnum, PEpath='PE0000'

!  allocate arrays for grid partition
        nepmax = maxval(nep) + maxval(nehalo)
        nppmax = maxval(npp) + maxval(nphalo)
        ALLOCATE (elemapG2Lp(ne),nodemapG2Lp(np),sidemapG2Lp(nsides),&
          nenp(nepmax,4),xyzp(nppmax,3),areap(nepmax),nbcp(nppmax),alfap(nppmax), &
          ieadjp(5,nepmax),numsideTp(4,nepmax),IECodep(nepmax), STAT = istat )

        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate main output arrays'
          call exit(71)
        endif
        
        if(nsides.gt.0) then
          nspmax = maxval(nsp) + maxval(nshalo)
          ALLOCATE (sdepp(0:nspmax),slenp(nspmax),refdepp(nspmax),sdxp(nspmax),sdyp(nspmax), &
            sxyp(2,nspmax),dlinvp(nspmax),isidep(3,nspmax),iendsp(2,nspmax), STAT = istat )
          if(istat.ne.0) then
            write(*,*) 'FATAL ERROR: Cannot allocate side-based storage arrays',istat
            call exit(71)
          endif
        endif

! *** form local domain arrays and write out      

      do jp=1,nproc
      
        myproc = jp-1
        if(myproc.lt.10) then
          write(PEnum,'(I1)') myproc
          PEpath(6:6) = PEnum(1:1)
        elseif(myproc.lt.100) then
          write(PEnum,'(I2)') myproc
          PEpath(5:6) = PEnum(1:2)
        elseif(myproc.lt.1000) then
          write(PEnum,'(I3)') myproc
          PEpath(4:6) = PEnum(1:3)
        elseif(myproc.lt.10000) then
          write(PEnum,'(I4)') myproc
          PEpath(3:6) = PEnum(1:4)
        else
          write(*,*) ' Fatal error: too many procs'
          stop
        endif
        
        netot = nep(jp) + nehalo(jp)
        nptot = npp(jp) + nphalo(jp)
        nstot = nsp(jp) + nshalo(jp)

        ! form local mappings
        elemapG2Lp = 0
        do j=1,netot
          nG = elemapL2G(j,jp)
          elemapG2Lp(nG) = j
        enddo
        nodemapG2Lp = 0
        do j=1,nptot
          nG = nodemapL2G(j,jp)
          nodemapG2Lp(nG) = j
        enddo
        sidemapG2Lp = 0        
        do j=1,nstot
          nG = sidemapL2G(j,jp)
          sidemapG2Lp(nG) = j
        enddo
        
        ! form local arrays for output
        nenp = 0
        iecodep = 1
        ieadjp = 0
        numsideTp = 0
        do j=1,netot
          eG = elemapL2G(j,jp)
          areap(j) = area(eG)
          iecodep(j) = iecode(eG)
          ieadjp(1,j) = j
          ncn2 = ncn -1 + min0(1,nen(eG,ncn))
          do k=1,ncn2
            nG = nen(eG,k)
            nenp(j,k) = nodemapG2Lp(nG)
            nG = ieadj(k+1,eG)
            if(nG.gt.0) ieadjp(k+1,j) = elemapG2Lp(nG)
            nG = numsideT(k,eG)
            numsideTp(k,j) = sidemapG2Lp(nG)
          enddo
        enddo
        
        xyzp = 0
        alfap = 0
        nbcp = 0
        do j=1,nptot
          nG = nodemapL2G(j,jp)
          xyzp(j,1:3) = xyz(nG,1:3)
          alfap(j) = alfa(nG)
          nbcp(j) = nbc(nG)
        enddo
        
! *** write it out
        call system('mkdir '//PEpath)
        OPEN(UNIT=22,file=PEpath//'/GridFile.xye',status='unknown')      
        
        write(22,'(a)') '#XYE'
        write(22,*) nptot,netot
        do j=1,nptot
          write(22,'(3e12.4,i5)') (xyzp(j,k),k=1,3),nbcp(j)
        enddo
        do j=1,netot
          write(22,'(4i7,i5)') (nenp(j,k),k=1,4),iecode(j)
        enddo
        close(22)
        
        OPEN(UNIT=22,file=PEpath//'/gridfile.bin',status='unknown',FORM='UNFORMATTED')      
        write(22) netot,nehalo(jp),nptot,nphalo(jp),NCN,nstot,nshalo(jp),izup,ifront
       
        write(22) ((NENp(J,K),K=1,NCN),J=1,netot),(IECodep(j),J=1,netot), &
              ((XYZp(J,K),J=1,NPtot),K=1,3),(ALFAp(j),J=1,NPtot),(NBCp(J),J=1,NPtot)
      
        if(nsides.gt.0) then
!  Side-based arrays
                         
          ! form local arrays
          isidep = 0
          sdepp(0)=sdep(0)
          do j=1,nstot  !p(jp)
            sG = sidemapL2G(j,jp)
            sdepp(j)=sdep(sG)
            slenp(j)=slen(sG)
            refdepp(j)=refdep(sG)
            sdxp(j)=sdx(sG)
            sdyp(j)=sdy(sG)
            dlinvp(j)=dlinv(sG)
            sxyp(1:2,j)=sxy(1:2,sG)
            do k=1,2
              nG = iside(k,sG)
              if(nG.gt.0) isidep(k,j)=elemapG2Lp(nG)
              nG = iends(k,sG)
              iendsp(k,j)=nodemapG2Lp(nG)
            enddo
            if(isidep(2,j).gt.0.and.isidep(1,j).gt.isidep(2,j)) then  !XXXXXXXcheck
              kk = isidep(2,j)
              isidep(2,j) = isidep(1,j)
              isidep(1,j) = kk
              sdxp(j) = -sdxp(j)
              sdyp(j) = -sdyp(j)
            endif
!            write(*,*) ' part,j,is1,is2= ',jp,j,isidep(1,j),isidep(2,j)
            isidep(3,j)=iside(3,sG)
          enddo
          ! update outer isides for halo to preserve correct direction
          do j=nsp(jp)+1,nstot
            isidep(1,j) = max(isidep(1,j),1)
            isidep(2,j) = max(isidep(2,j),1)
!            write(*,*) ' part,j,is1,is2= ',jp,j,isidep(1,j),isidep(2,j)
          enddo
        
          ! write it out
          write(22) (areap(j),j=1,netot),((ieadjp(k,j),k=1,5),j=1,netot),((numsideTp(k,j),j=1,netot),k=1,4) 
          write(22) ((isidep(k,j),k=1,2),j=1,nstot),((sxyp(k,j),k=1,2),j=1,nstot)
          write(22) (refdepp(j),j=1,nstot),(slenp(j),j=1,nstot)
          write(22) (sdxp(j),j=1,nstot),(sdyp(j),j=1,nstot),(dlinvp(j),j=1,nstot)
          write(22,IOSTAT=istat) ((iendsp(k,j),k=1,2),j=1,nstot)
        endif
! *** write map information
        write(22) nproc,jp,ne,np,nsides,numhalo
        write(22) (elemapG2Lp(j),j=1,ne),(elemapL2G(j,jp),j=1,netot)
        write(22) (nodemapG2Lp(j),j=1,np),(nodemapL2G(j,jp),j=1,nptot)
        write(22) (sidemapG2Lp(j),j=1,nsides),(sidemapL2G(j,jp),j=1,nstot)
! *** write comm information for this partition
        maxbufsize = max(maxval(ine(:,jp)),maxval(ene(:,jp)),maxval(ins(:,jp)),maxval(ens(:,jp)))
        write(22) ncomm(jp),maxbufsize
        do j=1,ncomm(jp)
          write(22) icomm(j,jp),ecomm(j,jp),ine(j,jp),ene(j,jp),ins(j,jp),ens(j,jp),inh(j,jp),enh(j,jp)
          write(22) (ipoly(k,j,jp),k=1,ine(j,jp))
          write(22) (epoly(k,j,jp),k=1,ene(j,jp))
          write(22) (iedge(k,j,jp),k=1,ins(j,jp))
          write(22) (eedge(k,j,jp),k=1,ens(j,jp))
          write(22) (ihalo(k,j,jp),k=1,inh(j,jp))
          write(22) (ehalo(k,j,jp),k=1,enh(j,jp))
        enddo
        CLOSE(unit=22)

! *** write base output
        OPEN(UNIT=22,file='baseout'//PEpath//'.dat',status='unknown')      
        write(22,*) 'netot,nehalo(jp),nptot,nphalo(jp),NCN,nstot,nshalo(jp),izup,ifront'
        write(22,*) netot,nehalo(jp),nptot,nphalo(jp),NCN,nstot,nshalo(jp),izup,ifront
        write(22,*) 'elements j,nen(j,1:ncn),iecode(j)'
        do j=1,netot
          write(22,'(10i6)') j,(nenp(j,k),k=1,4),iecodep(j)
        enddo
        write(22,*) 'elements j,area,ieadj(1:5,j),numside(1:4,j)'
        do j=1,netot
          write(22,'(i6,e12.4,10i6)') j,areap(j),(ieadjp(k,j),k=1,5),(numsideTp(k,j),k=1,4)
        enddo
        write(22,*) 'nodes j,xyz(j,1:3),alfa(j)'
        do j=1,nptot
          write(22,'(i6,4e12.4)') j,(xyzp(j,k),k=1,3),alfap(j)
        enddo
        write(22,*) 'sides j,iside(1:3,j),iends(1:2,j)'
        do j=1,nstot
          write(22,'(10i6)') j,(isidep(k,j),k=1,3),(iendsp(k,j),k=1,2)
        enddo
        write(22,*) 'sides j,iside(1:3,j),iends(1:2,j)'
        do j=1,nstot
          write(22,'(i6,8e12.4)') j,(sxyp(k,j),k=1,2),refdepp(j),slenp(j),sdxp(j),sdyp(j),dlinvp(j)
        enddo
        close(22)
      enddo

      RETURN
      END

!***************************************************************
!*****************************************************************

        subroutine ticktock(time1,time2)

          integer(8) ic8,crate8
          real time1,time2

! *** processor time
          call cpu_time(time1)
! *** system time
          call system_clock(count=ic8,count_rate=crate8)
          time2 = float(ic8)/float(crate8)

        return
        end

!***************************************************************
!***************************************************************

