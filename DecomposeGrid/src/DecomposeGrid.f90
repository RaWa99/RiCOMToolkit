! *********************************************************************

      PROGRAM DecomposeGrid

! *********************************************************************
! ***  DecomposeGrid
! ***  Decomposes grid for parallel execution of RiCOM, based on
! ***             partition table generated by Metis 4.
! ***  Reads preprocessed binary grid file for RiCOM (prepared by PreMod5)
! ***             Then divides grid in ncpu parts in separate directories.
! ***  Reference: Jacek
! ***  Written by: Roy A. Walters
! ***  
! ***  IMPORTANT NOTE:
! ***  This program is provided for personal use and may not be distributed
!      to anyone else without the author's explicit permission.
! *********************************************************************

! *********************************************************************
! *** Exit Codes
! *** 24 Mismatch in analysis times
! *** 70 unable to open input file
! *** 71 problem allocating arrays
! *** 72 Unknown parameter value/invalid input
! *** 73 Trouble with frontal solver 
! *** 74 No Convergence
! *** 75 Problem with wind file
! *********************************************************************

      USE SISL3DMOD
      
      implicit none

! *** local variables
      integer ivar(20)
      real rvar(5)
      real ctime0, stime0, ctime1, stime1, etime

      include 'RCMversion.h'

! *** initialization
      call ticktock(ctime0,stime0)
      CALL DataInput(ivar,rvar)
      
      call OutputGrids
      call ticktock(ctime1,stime1)
      etime = ctime1 - ctime0
      write(6,*) ' Elapsed proc time in input=', etime
      etime = stime1 - stime0
      write(6,*) ' Elapsed sys time in input=', etime


      STOP
      END

!*****************************************************************
!*****************************************************************

      SUBROUTINE DataInput(ivar, rvar)

! *** Read grid data created by PROGRAM PREMOD, read boundary data,
! *** and initialize model.

      USE SISL3DMOD

      implicit none

! *** passed variables
      integer ivar(*)
      real rvar(*)

! *** local variables
      integer :: i,j,k,istat,ierr
      integer nnp,nndf,npvx,ndfv,iopt
      real alfa
      logical ResOK, openfile
      CHARACTER FNAME*256, ans*1

! *** START
      write(*,*) ' A grid decomposition program for the model'
      write(*,*) ' RiCOM Version ',trim(version),' (River and Coastal Ocean Model)'
      write(*,*) ' created by Roy Walters,'
      write(*,*) ' Internet:  rawalters@gmail.com'
      write(*,*) ' Program size: Allocatable arays. A message will appear'
      write(*,*) '               if there is insufficient memory'
      write(*,*) ' '


! *** Initial values
      TET = 0.

      ResOK = OpenFile(22,'Open pre-processed Grid File',fname, &
     &    "Input file(*.rcm),*.rcm;All files(*.*),*.*;")

      if(.not.resOK) then
        write(*,*), 'Unable to open input file'
        call exit(71)
      endif

!      OPEN(UNIT=22,file=GridFileName,status='OLD',FORM='UNFORMATTED')      
      READ (22) NE,NTYPE,NP,NPR,NCN,nsides,nnbr,izup,ifront,maxrow,maxsto

!  Main arrays for grid
      ALLOCATE (nen(ne,ncn),xyz(np,3),mf1(np),fcor(np),area(ne),nbc(np), &
        ieadj(5,ne),numsideT(4,ne),IndexQ(ne),IECode(ne), STAT = istat )

      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate main storage arrays'
        call exit(71)
      endif

      READ (22) ((NEN(J,K),K=1,NCN),J=1,NE),(IECode(j),J=1,NE), &
     &         ((XYZ(J,K),J=1,NP),K=1,3),(ALFA,J=1,NP),         &
     &         (NBC(J),J=1,NP)
      
      if(nsides.gt.0) then
!  Side-based arrays  !,sv(nsides)
        ALLOCATE (sdep(0:nsides),slen(nsides),refdep(nsides),sdx(nsides),sdy(nsides), &
          sxy(2,nsides),dlinv(nsides),gamma(0:nsides),gammaFD(0:nsides),iside(3,nsides),&
          iends(2,nsides), STAT = istat )
        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate side-based storage arrays'
          call exit(71)
        endif

        READ(22) (area(j),j=1,ne),((ieadj(k,j),k=1,5),j=1,ne),((numsideT(k,j),j=1,ne),k=1,4) 
        READ(22) ((iside(k,j),k=1,2),j=1,nsides),((sxy(k,j),k=1,2),j=1,nsides)
        READ(22) (refdep(j),j=1,nsides),(slen(j),j=1,nsides)
        READ(22) (sdx(j),j=1,nsides),(sdy(j),j=1,nsides),(dlinv(j),j=1,nsides)
        READ(22,IOSTAT=istat) ((iends(k,j),k=1,2),j=1,nsides)
      else
        nsides = 0
      endif
      CLOSE(unit=22)
 
      write(6,*) ' ne,ncn,ntype=',ne,ncn,ntype
      write(6,*) ' np,nsides,nnbr=',np,nsides,nnbr


      ResOK = OpenFile(22,'Open Partition Table File',fname, &
     &    "Input file(*.lel),*.lel;All files(*.*),*.*;")

      if(.not.resOK) then
        write(*,*), 'Unable to open partition file'
        call exit(71)
      endif

      ALLOCATE (iepart(ne), STAT = istat )
      if(istat.ne.0) then
        write(*,*) 'FATAL ERROR: Cannot allocate partition array'
        call exit(71)
      endif
      
      do j=1,ne
        read(22,*) iepart(j)
      enddo

! *** restart file
      write(*,*) ' Decompose restart file? (Y/N)'
      READ(1,'(a)') ans
      
      if(ans(1:1).eq.'Y'.or.ans(1:1).eq.'y') then

        ResOK = OpenFile(2,'Open restart File',fname, &
          "Input file(*.bin),*.bin;All files(*.*),*.*;")

        if(.not.resOK) then
          write(*,*), 'Unable to open restart file'
          call exit(71)
        endif
        
        irst = 1

! *** If iwind = 3 (i.e. NZLAM wind/pressure input) read in Analysis time for restart file
        IF ((iwind .eq. 2) .or. (iwind .eq. 3)) THEN
          READ(2) TET,nnp,nndf,npvx,ndfv,iopt,iAnalysisTime
		  write(*,*), 'Analysis time from restart file', iAnalysisTime
        ELSE
          READ(2) TET,nnp,nndf,npvx,ndfv,iopt
        END IF
 
        ndim = max(nsides,ne+nsidesbc)
        npv = npvx
        allocate ( eta(0:ndim),un(npv,nsides),ut(npv,nsides),ut1(npv,nsides),&
                   ut2(npv,nsides), STAT = istat )
        if(istat.ne.0) then
          write(*,*) 'FATAL ERROR: Cannot allocate dependent variables'
          call exit(71)
        endif
        
        READ(2) (eta(I),I=1,nnp),(un(1,i),i=1,nnp),(ut(1,i),i=1,nnp)
!        eta = amax1(eta-0.1,elev)
        if(npvx.gt.1) then
          do k=2,npvx
            read(2,end=188) (un(k,j),j=1,nnp),(ut(k,j),j=1,nnp)
          enddo
        endif
        ut1 = ut
        ut2 = ut
        read(2,end=188) ((ut1(k,j),k=1,npvx),j=1,nnp)
        read(2,end=188) ((ut2(k,j),k=1,npvx),j=1,nnp)
188     CLOSE (unit=2)
      else
        irst = 0
      endif

      RETURN

! *** format statements
! 6030 FORMAT( / 2X,'FRICTION AND DISPERSION PARAMETERS')
! 6031 FORMAT(I11,1P7E13.3)
!  611 FORMAT(1X,2(I5,6F10.5))
!  621 FORMAT(22X,'NE=',I7,' ,NP=',I7,' NEQS=',I7,' NDF=',I2)
! 6025 FORMAT(5X,'WIND DIRECTION=',F5.1,' DEG.,SPEED=',F5.1,' M/S,&
!     & SIGMAX=',1PE11.2,' ,SIGMAY=',1PE11.2)
! 6105 FORMAT(10X,'FILENAME FOR ELEMENT DATA:',5X,A)
! 6112 FORMAT(15X,A)
! 6120 FORMAT(10X,'FILENAMES FOR RMS DATA:')
 6125 FORMAT(10X,'FILENAME FOR RESTART DATA:',5X,A)
! 6127 FORMAT(10X,'FILENAME FOR OUTPUT DATA:',5X,A)
! 6151 FORMAT(10X,'PARAMETERS: Latitude=',F7.3,' ,ELEV=',F7.3,&
!     &           ' ,zminq=',F7.3,' ,PERIOD=',F10.5)
! 6701 FORMAT(10X,'IFR=',I3,' ,ITN=',I3,' ,IWN=',I3)
! 6702 FORMAT(10X,' IVFR=',I3,' ,IvSf=',I3,' ,Ihfr=',I3,' ,IFD=',I3)

      END

!*****************************************************************
!*****************************************************************

      Subroutine OutputGrids

      USE SISL3DMOD
      
      implicit none

! *** local variables

      RETURN
      END

!***************************************************************
!*****************************************************************

        subroutine ticktock(time1,time2)

          integer(8) ic8,crate8
          real time1,time2

! *** processor time
          call cpu_time(time1)
! *** system time
          call system_clock(count=ic8,count_rate=crate8)
          time2 = float(ic8)/float(crate8)

        return
        end

!***************************************************************
!***************************************************************

